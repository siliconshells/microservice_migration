name: Build and Deploy Services

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com

jobs:
  terraform:
    runs-on: ubuntu-latest
    outputs:
      instance1_ip: ${{ steps.tf-output.outputs.instance1_ip }}
      instance2_ip: ${{ steps.tf-output.outputs.instance2_ip }}
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Terraform Init
        run: terraform init
        working-directory: ./terraform
      
      - name: Import Existing Resources
        run: |
          terraform import aws_iam_role.ec2_role ec2-ecr-role 2>/dev/null || true
          terraform import aws_iam_instance_profile.ec2_profile ec2-ecr-profile 2>/dev/null || true
          terraform import aws_ecr_repository.service1 service1 2>/dev/null || true
          terraform import aws_ecr_repository.service2 service2 2>/dev/null || true
          
          ALB_ARN=$(aws elbv2 describe-load-balancers --names services-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "")
          [ ! -z "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ] && terraform import aws_lb.main "$ALB_ARN" 2>/dev/null || true
          
          TG1_ARN=$(aws elbv2 describe-target-groups --names service1-tg --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
          [ ! -z "$TG1_ARN" ] && [ "$TG1_ARN" != "None" ] && terraform import aws_lb_target_group.service1 "$TG1_ARN" 2>/dev/null || true
          
          TG2_ARN=$(aws elbv2 describe-target-groups --names service2-tg --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
          [ ! -z "$TG2_ARN" ] && [ "$TG2_ARN" != "None" ] && terraform import aws_lb_target_group.service2 "$TG2_ARN" 2>/dev/null || true
          
          if [ ! -z "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
            LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" --query 'Listeners[0].ListenerArn' --output text 2>/dev/null || echo "")
            [ ! -z "$LISTENER_ARN" ] && [ "$LISTENER_ARN" != "None" ] && terraform import aws_lb_listener.http "$LISTENER_ARN" 2>/dev/null || true
            
            if [ ! -z "$LISTENER_ARN" ] && [ "$LISTENER_ARN" != "None" ]; then
              RULE1_ARN=$(aws elbv2 describe-rules --listener-arn "$LISTENER_ARN" --query 'Rules[?Priority==`100`].RuleArn' --output text 2>/dev/null || echo "")
              [ ! -z "$RULE1_ARN" ] && [ "$RULE1_ARN" != "None" ] && terraform import aws_lb_listener_rule.service1 "$RULE1_ARN" 2>/dev/null || true
              
              RULE2_ARN=$(aws elbv2 describe-rules --listener-arn "$LISTENER_ARN" --query 'Rules[?Priority==`200`].RuleArn' --output text 2>/dev/null || echo "")
              [ ! -z "$RULE2_ARN" ] && [ "$RULE2_ARN" != "None" ] && terraform import aws_lb_listener_rule.service2 "$RULE2_ARN" 2>/dev/null || true
            fi
          fi
        working-directory: ./terraform
      
      - name: Terraform Apply
        run: terraform apply -auto-approve -var="key_pair_name=${{ secrets.KEY_PAIR_NAME }}"
        working-directory: ./terraform
      
      - name: Get Terraform Outputs
        id: tf-output
        run: |
          echo "instance1_ip=$(terraform output -raw service1_instance_ip)" >> $GITHUB_OUTPUT
          echo "instance2_ip=$(terraform output -raw service2_instance_ip)" >> $GITHUB_OUTPUT
        working-directory: ./terraform
      
      - name: Configure EC2 Instances
        env:
          PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          INSTANCE1_IP: ${{ steps.tf-output.outputs.instance1_ip }}
          INSTANCE2_IP: ${{ steps.tf-output.outputs.instance2_ip }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          echo "$PRIVATE_KEY" > private_key.pem
          chmod 600 private_key.pem
          
          for INSTANCE_IP in $INSTANCE1_IP $INSTANCE2_IP; do
            until ssh -o StrictHostKeyChecking=no -i private_key.pem ubuntu@$INSTANCE_IP 'echo ready'; do
              echo "Waiting for instance $INSTANCE_IP..."
              sleep 10
            done
            
            ssh -o StrictHostKeyChecking=no -i private_key.pem ubuntu@$INSTANCE_IP "echo 'export AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID' >> ~/.bashrc"
          done

  build-and-push:
    needs: terraform
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        run: aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
      
      - name: Build and push service1
        run: |
          docker build -t ${{ env.ECR_REGISTRY }}/service1:latest ./servers/service1
          docker push ${{ env.ECR_REGISTRY }}/service1:latest
      
      - name: Build and push service2
        run: |
          docker build -t ${{ env.ECR_REGISTRY }}/service2:latest ./servers/service2
          docker push ${{ env.ECR_REGISTRY }}/service2:latest

  deploy:
    needs: [terraform, build-and-push]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Deploy to EC2 instances
        env:
          PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          INSTANCE1_IP: ${{ needs.terraform.outputs.instance1_ip }}
          INSTANCE2_IP: ${{ needs.terraform.outputs.instance2_ip }}
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          echo "$PRIVATE_KEY" > private_key.pem
          chmod 600 private_key.pem
          
          for INSTANCE_IP in $INSTANCE1_IP $INSTANCE2_IP; do
            scp -o StrictHostKeyChecking=no -i private_key.pem ./servers/docker-compose.yml ubuntu@$INSTANCE_IP:/home/ubuntu/
            ssh -o StrictHostKeyChecking=no -i private_key.pem ubuntu@$INSTANCE_IP "export AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID && aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $ECR_REGISTRY && cd /home/ubuntu && docker-compose down && docker-compose pull && docker-compose up -d"
          done
